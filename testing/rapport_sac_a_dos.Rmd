---
title: "Knapsack Problem"
author: "Alexandre Combeau, Mohtadi Hammami, Ninette Hounkponou"
date: "2025-04-11"
output: html_document
---

```{r setup, include=FALSE}
library(knapsack2)
library(Rcpp)
devtools::document()
devtools::load_all()
```

# Description

Le **problème du sac à dos** est un problème classique d’optimisation combinatoire. On cherche à sélectionner un sous-ensemble d’objets, chacun ayant un poids et une valeur, de manière à **maximiser la valeur totale** transportée **sans dépasser une capacité maximale**.

Soient $n$ objets, chacun défini par :

- un poids $p_i\in\mathbb{N}^*$,

- une valeur $v_i\in\mathbb{R}_+$,

- un poids maximal autorisé $W\in\mathbb{N}^*$

L’objectif est de résoudre le problème suivant :

$$\max_{x\in\{0,1\}^n}\sum_{i=1}^{n}v_ix_i\quad\text{sous la contrainte}\quad \sum_{i=1}^{n}p_ix_i\le W$$
où $x_i$ est une variable de sélection qui vaut 1 si l’objet $i$ est selectionné et 0 sinon.

Nous présentons ici trois méthodes pour résoudre ce problème :

- Algorithme **brute force**

- Algorithme **glouton**

- Algorithme de **programmation dynamique**

---

# 1. Première méthode : Brut Force
## Description
L'algorithme **brute force** / **exhaustif**, consiste à regarder toutes les combinaisons possibles d'objets dans le sac, sans aucune optimisation préalable. Puisque nous disposons de $n$ objets, il y a exactement $2^n$ sous-ensembles possibles.

L'idée de base est donc de générer toutes les configurations binaires possibles de sélection d'objets $x\in\{0,1\}^n$. Pour CHAQUE configuration :

- on calcule le poids total : $p(x)=\sum_{i=1}^np_ix_i$

- on calcule la valeur totale : $v(x)=\sum_{i=1}^nv_ix_i$

Si $P(x)\le W$, alors la configuration est **valide** (mais pas optimale).

La configuration qui maximisera $v(x)$ sera donc la solution optimale.

## Exemple

```{r exemple_naif}
set.seed(42)
n = 10
poids <- sample(10,n)
valeur <- sample(30,n)
poids_max <- 20
sac_a_dos(poids, valeur, poids_max)
```

## Complexité

L’algorithme teste toutes les $2^n$ combinaisons possibles.
Pour chaque combinaison, il fait deux opérations de somme sur $n$ éléments : $O(n)$.

La complexité totale est donc $$O(n2^n).$$

## Comparaison R / C++

```{r}
set.seed(42)
n <- 20
poids <- runif(n)
valeurs <- runif(n)
p_max <- 2
time1 <- system.time(sac_a_dos(poids, valeurs, p_max))
time2 <- system.time(rcpp_sac_a_dos(poids, valeurs, p_max))
time1[[1]]/time2[[1]]

# Comparaison des performances
library(microbenchmark)
res <- microbenchmark(
  sac_a_dos(poids, valeurs, p_max),       # Version R
  rcpp_sac_a_dos(poids, valeurs, p_max),  # Version C++
  times = 10
)
print(res)
library(ggplot2)
autoplot(res)
```

